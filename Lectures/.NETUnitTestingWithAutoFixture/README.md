# .NET Unit Testing with AutoFixture

## 목표
- Simplify the arrange phase
- Generate anonymous test data
- Customize anonymous object creation
- Increase productivity

## 목차
1. Getting Started with AutoFixture
   - 1.1 Introduction
   - 1.2 Simplifying the Arrange Phase of Tests with AutoFixture
   - 1.3 Supported Frameworks
   - 1.4 Introducing the Fixture Class
   - 1.5 Creating a Test Project and Installing AutoFixture
   - 1.6 Writing an Initial Test with Non-anonymous Test Data
   - 1.7 Writing a Test with Manual Anonymous Test Data
   - 1.8 Using an AutoFixture Fixture Instance to Create Anonymous Test Data
   - 1.9 Summary
1. Creating Anonymous Test Data and Objects with AutoFixture
   - 2.1 Introduction
   - 2.2 Creating Anonymous Strings
   - 2.3 Creating Anonymous Numbers
   - 2.4 Creating Anonymous Dates and Times
   - 2.5 Creating Enums and GUIDs
   - 2.6 Generating Email Addresses
   - 2.7 Creating Sequences of Anonymous Values
   - 2.8 Creating Anonymous Instances of Custom Types
   - 2.9 Creating Complex Anonymous Object Graphs
   - 2.10 Creating Objects with DataAnnotations
   - 2.11 Summary
1. Customizing AutoFixture Object Creation
   - 3.1 Introduction
   - 3.2 Customizing Values Generated by a Fixture Instance
   - 3.3 Freezing Values in AutoFixture
   - 3.4 Using the AutoFixture Test Data Builder Pattern
   - 3.5 Understanding Specimens and the AutoFixture Pipeline
   - 3.6 Examples of Prebuilt Customizations
   - 3.7 Creating a Custom AutoFixture Specimen Builder
   - 3.8 Summary
1. Writing Less Test Code and Improving Test Maintenance
   - 4.1 Introduction
   - 4.2 The Problem with Manual Test Data Creation
   - 4.3 Creating Refactor-safe Test Code with AutoFixture
   - 4.4 Parameterized xUnit.net Tests with Anonymous Data
   - 4.5 Auto-mocking with AutoFixture and Moq
   - 4.6 Combining Auto Mocking and Auto Data in xUnit.net
   - 4.7 Using AutoFixture to Improve Code Design and Maintainability
   - 4.8 Summary and Further Learning

<br/>

## 1. Getting Started with AutoFixture

### 1.1 Introduction
#### The Benefits of AutoFixture
- Increase productivity
- Reduce test maintenance
- Improve test readability
- Less test code

* 변경 전
  ```cs
  [Fact]
  public void SubtractWhenZeroTest()
  {
    // Arrange
    var sut = new Calculator();
    
    // Act
    sut.Subtract(1);
    
    // Assert
    Assert.True(sut.Value < 0);
  }
  ```
* 변경 후
  ```cs
  [Theory, AutoData]
  public void SubtractWhenZeroTest(int aPositiveNumber, Calculator sut)
  {
    // Act
    sut.Subtract(aPositiveNumber);
    
    // Assert
    Assert.True(sut.Value < 0);
  }
  ```

### 1.2 Simplifying the Arrange Phase of Tests with AutoFixture
#### Simplify and reduce arrange phase code
- 변경 전 : Arrange -> Act -> Assert
- 변경 후 
  - Arrange(Anonymous test data : AutoFixture) -> Act -> Assert
  - AutoFixture -> Act -> Assert

#### Anonmous Test Data
- Data that is required to be present for the test to be able to execute, but where the value itself is unimportant.
- 변경 전
  ```cs
  [Fact]
  public void SubtractWhenZeroTest()
  {
    // Arrange
    var sut = new Calculator();
    
    // Act
    sut.Subtract(1);  // 1 : Known test data
                      //     specify the test data manually
                      //     as long as it's a positive value
    
    // Assert
    Assert.True(sut.Value < 0);
  }
  ```
- 변경 후
  ```cs
  [Theory, AutoData]
  public void SubtractWhenZeroTest(int aPositiveNumber, Calculator sut)
  {
    // Act
    sut.Subtract(aPositiveNumber);   // aPositiveNumber : Anonymous test data
    
    // Assert
    Assert.True(sut.Value < 0);
  }
  ```
- AutoFixture
  - AutoFixture is an open source library for .NET designed to **minimize the 'Arrange' phase** of your unit tests in order to **maximize maintainability**. Its primary goal is to allow developers to focus on **what is being tested** rather than **how to setup the test scenario**, by making it easier to **create object graphs containing test data**.
  
### 1.3 Supported Frameworks
- AutoFixture is indenpendent of the testing framework or test runner.
- 지원 패키지
  - NUnit
  - xUnit.net
  - MSTest
  - Fixie
- .NET Framework : 4.5.2
- .NET Standard : 1.5, 2.0

### 1.4 Introducing the Fixture Class
- Test method - Fixture class - string, ...

### 1.5 Creating a Test Project and Installing AutoFixture
- [AutoFixture NuGet 4.13.0](https://www.nuget.org/packages/AutoFixture/)
- 4.11.0 예제 구성

### 1.6 Writing an Initial Test with Non-anonymous Test Data
- public : 테스트 클래스
- [Fact] : 단위 테스트 메서드 애트리뷰트
- Anonymous test data : 테스트를 수행하는 과정에서 실제 값이 무엇인지는 중요하지 않다(알 필요가 없다). 
 
### 1.7 Writing a Test with Manual Anonymous Test Data
- 상수 : ```1```
  ```cs
  [Fact]
  public void Create_AnonymousTestData_Manually()
  {
      // Arrnage
      var sut = new IntCalculator();
  
      // Act
      sut.Subtract(1);    // 1 : Anonymous test data
  
      // Assert
      Assert.True(sut.Value < 0);
  }
  ```
- 변수 : ```int aPositiveNumber = 1;```
  ```cs
  [Fact]
  public void Create_AnonymousTestData_Manually_By_Variable()
  {
      // Arrnage
      var sut = new IntCalculator();
      int aPositiveNumber = 1;   // 1 : Anonymous test data
  
      // Act
      sut.Subtract(aPositiveNumber);
  
      // Assert
      Assert.True(sut.Value < 0);
  }  
  ```
 
### 1.8 Using an AutoFixture Fixture Instance to Create Anonymous Test Data
- Fixture 클래스 : _TODO : fixture.Create<T> 음수 값이 없나???_
  ```cs
  [Fact]
  public void Create_AnonymousTestData_Automatically_By_AutoFixtrue()
  {
      // Arrnage
      var sut = new IntCalculator();
      var fixture = new Fixture();
      int aPositiveNumber = fixture.Create<int>(); // Anonymous test data : 실제 값은 중요하지 않다.
  
      // Act
      sut.Subtract(aPositiveNumber);
  
      // Assert
      Assert.True(sut.Value < 0);
  }
  ```

<br/>

## 2. Creating Anonymous Test Data and Objects with AutoFixture
### 2.1 Introduction
- Create anonymous test data
  - strings
  - numbers : int, float, double, ...
  - dates & times
  - enums & GUIDs
  - email addresses
  - sequences of anonymous values
  - instances of custom types
  - complex anonymous object graphs
  - objects with DataAnnotations
 
### 2.2 Creating Anonymous Strings
- ```fixture.Create<string>();```, ```fixture.Create<char>();```
  - **constrain the range of random values**을 생성한다.
    - firstName	: "42ee27f7-b895-4562-855a-c8af8a2080ae", string
    - lastName	: "67ff5868-6e34-4820-bff0-9966eae1251c", string
- ```Create<T>(this ISpecimenBuilder builder)``` vs. ```Create<T>(this ISpecimenBuilder builder, T seed)```
  - ```public static T Create<T>(this ISpecimenBuilder builder)``` : Creates an anonymous variable of the requested type.
  - ```public static T Create<T>(this ISpecimenBuilder builder, T seed)``` : Creates an anonymous object, potentially using the supplied seed as additional information when creating the object.
    - [AutoFixture.SeedExtensions NuGet 4.13.0](https://www.nuget.org/packages/AutoFixture.SeedExtensions/) : Extensions for the most common AutoFixture operations to provide overloads with a seed.
    - 예. fixture.Create("First_");
  
### 2.3 Creating Anonymous Numbers
- Use anonymous values only when they **don't have a specific meaning to the SUT**.
- [Constrained Non-Determinism](https://blog.ploeh.dk/2009/03/05/ConstrainedNon-Determinism/)
  - For **input** where **the value** holds **a particular meaning in the context of the SUT**, you will still need to hand-pick values as always. E.g. if the input is expected to be an XML string conforming to a particular schema, a Guid string makes no sense.
- A given test must execute the same production code every time it is executed.
  - Anonymous values **should not affect logical program flow**.
- Numbers
  - ```fixture.Create<byte>();```
  - ```fixture.Create<double>();```
  - ```fixture.Create<short>();```
  - ```fixture.Create<long>();```
  - ```fixture.Create<sbyte>();```
  - ```fixture.Create<float>();```
  - ```fixture.Create<ushort>();```
  - ```fixture.Create<int>();```
  - ```fixture.Create<uint>();```
  - ```fixture.Create<ulong>();```
 
### 2.4 Creating Anonymous Dates and Times
- DateTime : ```fixture.Create<DateTime>();```
- TimeSpan : ```fixture.Create<TimeSpan>();```

### 2.5 Creating Enums and GUIDs
- Guid : ```fixture.Create<Guid>();```
- Enum : ```fixture.Create<EmailMessageType>();```
  ```cs
  public enum EmailMessageType
  {
        Unspecified,
        Sales,
        Support,
        AccountManagement
  }
  ```
### 2.6 Generating Email Addresses
- 네임스페이스 : ```using System.Net.Mail;```
- 타입
  - MailAddress
  - EmailAddressLocalPart
  - DomainName
- 메일 타입
  - ```fixture.Create<MailAddress>()```
  - ```fixture.Create<EmailAddressLocalPart>().LocalPart```
  - ```fixture.Create<DomainName>().Domain```
    
### 2.7 Creating Sequences of Anonymous Values
- ```CreateMany<T>``` : ```IEnumerable<T>``` 객체 생성 후 데이터를 추가한다(기본 3개).
  - ```public static IEnumerable<T> CreateMany<T>(this ISpecimenBuilder builder``` : 3개 
  - ```public static IEnumerable<T> CreateMany<T>(this ISpecimenBuilder builder, int count)``` : 갯수 지정 
- ```AddManyTo<T>``` : 생성된 ```IEnumerable<T>```에 데이터를 추가한다(기본 3개). 
  - ```public static void AddManyTo<T>(this IFixture fixture, ICollection<T> collection)``` : 3개
  - ```public static void AddManyTo<T>(this IFixture fixture, ICollection<T> collection, int repeatCount)``` : 갯수 지정
  - ```public static void AddManyTo<T>(this IFixture fixture, ICollection<T> collection, Func<T> creator)``` : 사용자 정의 데이터 생성

### 2.8 Creating Anonymous Instances of Custom Types
- 기본타입 매개변수 생성자
  ```cs
  public EmailMessage(
    string toAddress, 
    string messageBody, 
    bool isImportant)
  {
    ToAddress = toAddress;
    IsImportant = isImportant;

    // 생성자 매개변수로 AutoFixture가 접근한다. 
    // 접두사는 매개변수 이름이 된다.
    // 예. MessageBody "messageBodyb0238ae0-fa72-418c-be95-b6428048813e", string
    MessageBody = messageBody;
  }

  public string ToAddress { get; set; }
  public bool IsImportant { get; set; }

  // AutoFixture가 접근할 수 없다
  public string MessageBody { get; private set; }     
  ```
- 생성자 데이터 주입
  - AutoFixture는 생성자의 기본타입 매개변수를 자동으로 주입한다.
  ```cs
  var message = fixture.Create<EmailMessage>();
    // +Id	                {ce30fbdb-8cdd-4e03-ad98-c1911b567b85}, ystem.Guid
    // IsImportant	        false, bool
    // MessageBody	        messageBodyb0238ae0-fa72-418c-be95-b6428048813e", string
    // MessageType	        Unspecified, Ch2.CreatingFixture.mailMessageType
    // SomePrivateProperty	null, string
    // SomePublicField	    SomePublicField0f1c2f1c-b9fb-4ea2-9f2a-d4e17ed7b6c1", string
    // SomePublicProperty	SomePublicProperty8181b948-e3ad-413d-a1cd-87092df4ecae", string
    // ToAddress	        ToAddressebddc868-2a7b-4a31-a25a-9854c515521f", string
    // _somePrivateField	null, string
  ```
### 2.9 Creating Complex Anonymous Object Graphs
- 사용자 정의타입 매개변수 생성자
  ```cs
  public Order(Customer customer)
  {
    // ...
  }
  ```
- 생성자 데이터 주입
  - AutoFixture는 생성자의 기본타입과 사용자 정의타입 매개변수를 자동으로 주입한다. 
  ```cs
  var order = fixture.Create<Order>();
  ```
- 생성자 데이터 주입(AutoFixture 없이)
  ```cs
  // Arrange
  var customer = new Customer()
  {
      CustomerName = "Eugene"
  };

  var order = new Order(customer)
  {
      Id = 42,
      OrderDate = DateTime.Now,
      Items =
      {
          new OrderItem
          {
              ProductName = "Notebook",
              Quantity = 2
          }
      }
  };
  ```
### 2.10 Creating Objects with DataAnnotations

- [System.ComponentModel.DataAnnotations 네임스페이스](https://docs.microsoft.com/ko-kr/dotnet/api/system.componentmodel.dataannotations?view=netcore-3.1)
  - StringLength : 데이터 필드에서 허용하는 최소 및 최대 문자 길이를 지정합니다.
  - Range : 데이터 필드의 값에 대해 숫자 범위 제약 조건을 지정합니다.
  ```cs
  using System.ComponentModel.DataAnnotations;

  public class PlayerCharacter
  {
      [StringLength(20)]
      public string RealName { get; set; }

      [StringLength(8)]
      public string GameCharacterName { get; set; }

      [Range(0, 100)]
      public int CurrentHealth { get; set; }
  }
  ```
- 단위 테스트
  ```cs
  [Fact]
  public void Create_DataAnnotation()
  {
      // Arrange
      var fixture = new Fixture();
      
      // Act
      var playerCharacter = fixture.Create<PlayerCharacter>();

      // Assert
      Assert.Equal(20, playerCharacter.RealName.Length);
      Assert.Equal(8, playerCharacter.GameCharacterName.Length);
      Assert.InRange<int>(playerCharacter.CurrentHealth, 0, 100);
  }
  ```

### 2.11 Summary
- Anonymous test data 정의
  - Use anonymous values only when they **don't have a specific meaning to the SUT**.
  - Anonymous values **should not affect logical program flow**.

<br/>

## 3. Customizing AutoFixture Object Creation
### 3.1 Introduction
### 3.2 Customizing Values Generated by a Fixture Instance
### 3.3 Freezing Values in AutoFixture
### 3.4 Using the AutoFixture Test Data Builder Pattern
### 3.5 Understanding Specimens and the AutoFixture Pipeline
### 3.6 Examples of Prebuilt Customizations
### 3.7 Creating a Custom AutoFixture Specimen Builder
### 3.8 Summary

<br/>

## 4. Writing Less Test Code and Improving Test Maintenance
### 4.1 Introduction
### 4.2 The Problem with Manual Test Data Creation
### 4.3 Creating Refactor-safe Test Code with AutoFixture
### 4.4 Parameterized xUnit.net Tests with Anonymous Data
### 4.5 Auto-mocking with AutoFixture and Moq
### 4.6 Combining Auto Mocking and Auto Data in xUnit.net
### 4.7 Using AutoFixture to Improve Code Design and Maintainability
### 4.8 Summary and Further Learning